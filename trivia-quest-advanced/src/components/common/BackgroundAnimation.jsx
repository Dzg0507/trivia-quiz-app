import React, { useEffect, useRef, useCallback } from 'react';import gsap from 'gsap';import * as THREE from 'three';const createScene = (mount) => {  const scene = new THREE.Scene();  const camera = new THREE.PerspectiveCamera(75, mount.clientWidth / mount.clientHeight, 0.1, 1000);  camera.position.z = 30;  const renderer = new THREE.WebGLRenderer({ alpha: true });  renderer.setSize(mount.clientWidth, mount.clientHeight);  mount.appendChild(renderer.domElement);  const geometry = new THREE.TorusKnotGeometry(10, 3, 100, 16);  const material = new THREE.MeshPhongMaterial({ color: 0xffcc00, specular: 0xffffff, shininess: 100 });  const torusKnot = new THREE.Mesh(geometry, material);  scene.add(torusKnot);  const light = new THREE.PointLight(0xffffff, 1, 100);  light.position.set(10, 10, 10);  scene.add(light);  return { scene, camera, renderer, torusKnot, light };};const BackgroundAnimation = () => {  const mountRef = useRef(null);  const animationFrameRef = useRef(null);  const { current: state } = useRef({    scene: null,    camera: null,    renderer: null,    torusKnot: null,    light: null,  });  const animate = useCallback(() => {    if (state.torusKnot) {      gsap.to(state.torusKnot.rotation, {        x: '+=0.005',        y: '+=0.005',        duration: 0.1,        ease: 'none',      });    }    if (state.renderer && state.scene && state.camera) {      state.renderer.render(state.scene, state.camera);    }    animationFrameRef.current = requestAnimationFrame(animate);  }, [state]);  const handleResize = useCallback(() => {    if (state.camera && state.renderer && mountRef.current) {      state.camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;      state.camera.updateProjectionMatrix();      state.renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);    }  }, [state]);  useEffect(() => {    const mount = mountRef.current;    if (!mount) return;    const { scene, camera, renderer, torusKnot, light } = createScene(mount);    state.scene = scene;    state.camera = camera;    state.renderer = renderer;    state.torusKnot = torusKnot;    state.light = light;    animate();    window.addEventListener('resize', handleResize);    return () => {      window.removeEventListener('resize', handleResize);      if (animationFrameRef.current) {        cancelAnimationFrame(animationFrameRef.current);      }      if (state.renderer) {        state.renderer.domElement.remove();        state.renderer.dispose();      }      if (state.scene) {        state.scene.remove(state.torusKnot);        state.scene.remove(state.light);        if (state.torusKnot) {          state.torusKnot.geometry.dispose();          state.torusKnot.material.dispose();        }      }    };  }, [animate, handleResize, state]);  return <div ref={mountRef} className="absolute top-0 left-0 w-full h-full opacity-30 z-[-1]" />;};export default BackgroundAnimation;